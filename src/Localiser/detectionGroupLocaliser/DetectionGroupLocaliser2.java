package Localiser.detectionGroupLocaliser;

import java.util.ArrayList;

import pamMaths.PamVector;
import Localiser.LocaliserModel;
import Localiser.LocaliserPane;
import Localiser.algorithms.genericLocaliser.Chi2Bearings;
import Localiser.algorithms.genericLocaliser.Chi2TimeDelays;
import Localiser.algorithms.genericLocaliser.MinimisationAlgorithm;
import Localiser.algorithms.genericLocaliser.MinimisationFunction;
import Localiser.algorithms.genericLocaliser.simplex.Simplex;
import Localiser.algorithms.locErrors.LocaliserError;
import PamDetection.AbstractLocalisation;
import PamDetection.LocContents;
import PamUtils.LatLong;
import PamguardMVC.PamConstants;
import PamguardMVC.PamDataUnit;
import PamguardMVC.superdet.SuperDetection;

/**
 * Localiser which deals with detections in which one or more groups of
 * detections are being localised. <br>
 * This localiser will usually be used with target motion localisation, however
 * could also be used for situation with multiple unsynced systems. e.g. DIFAR
 * buoys <br>
 * This is a generic localiser which can implement multiple localisation
 * algorithms. There are two main variables to set. What type of data to use for
 * the localisation from the AbstractLoclaisation class e.g. time delays or
 * bearings and the type of localisation algortihm to use.
 * <p>
 * Information of time delays, bearings, locations of hydrophones etc. is
 * generated by a GroupLocInfo class. This can be subclassed and the
 * getGroupLocInfo(T PamDetection) overridden to generate data more suited to
 * different types of system. The default GroupLocInfo class is designed mainly
 * for target motion localisation.
 * 
 * @param <T> - the type of PamDataUnit
 *
 */
public class DetectionGroupLocaliser2<T extends SuperDetection> implements LocaliserModel<T>  {
	
	/**
	 * Name of the localisation algorithm 
	 */
	private String name="Detection Group Loclaiser";
	
	/**
	 * Some text describing the localisation algorithm. 
	 */
	private String toolTip="Localises a group of detections";
	
	/**Minimisation function types/ data to use for localisation**/ 
	
	/**
	 * Flag to use whatever the abstract localiser has. Will try with 
	 * bearings first then will try with time delays. 
	 */
	public final static int AUTOMATIC=0x1;
	
	/**
	 * Flag to use the bearings to localise.  
	 */
	public final static int BEARINGS_GROUP=0x2;
	
	/**
	 * Flag to use time delays localise. 
	 */
	public final static int TIMEDELAY_GROUP=0x4;
	
	/**
	 * Flag to indicate what localisation type to use. 
	 */
	private int locType=BEARINGS_GROUP;

	/*
	 *Flag which indicates what type of information to try and localise with. 
	 * 
	 */
	private MinimisationAlgorithm locAlgorithm=new Simplex();
	

	/**
	 * Class for calculating localisation information to be input into 
	 * Localisation algorithms. 
	 */
	private GroupLocInfo groupLocInfo;

	/**
	 * The number of dimensions to solve for. 
	 */
	private int nDim=2;
	
	/**
	 * Creates a default group localiser. Solves for two dimensions using the Simplex localisation method. 
	 * Will by default set up the localisation problem with bearings rather than time delays. 
	 */
	public DetectionGroupLocaliser2(String name){
		this.name=name;
	}

	
	/**
	 * Constructor for a group localiser. 
	 * @param name - the name of the localiser. Will appear on dialogs, in the database etc. 
	 * @param locAlgorithm - the type of localisation algorithm to use e.g. Least Squares, Simplex etc. 
	 * @param dataType - the type of data to use for localisation, generally bearings or use raw time delays. 
	 * @param nDim - the number of dimensions to solve for. Either 2 or 3. 
	 */
	public DetectionGroupLocaliser2(String name, MinimisationAlgorithm locAlgorithm, int dataType, int nDim){
		this.name=name;
		this.locAlgorithm=locAlgorithm;
		this.locType=dataType;
		this.nDim=nDim; 
	}
	

	@Override
	public String getName() {
		return name;
	}

	@Override
	public String getToolTipText() {
		return toolTip + " using a " + name + " algorithm"; 
	}

	@Override
	public LocContents getLocContents() {
		//no loc contents for this localiser. 
		return null;
	}

	@Override
	public LocaliserPane getAlgorithmSettingsPane() {
		return locAlgorithm.getSettingsPane(); 
	}

	@Override
	public GroupLocalisation runModel(T pamDataUnit, DetectionGroupOptions detectionGroupOptions, boolean addLoc) {
		
		//System.out.println("DetectionGroupLocaliser2: New localiser attempting to localise some data units: " + pamDataUnit.getSubDetectionsCount());
		
		GroupLocInfo groupInfo=getGroupLocInfo(pamDataUnit, detectionGroupOptions);
		
		//set up the the function for forward problem. 
		MinimisationFunction[] minFunctuion=getMinimsationFunc(groupInfo, locType);
		
		//use an algorithm to solve the minimisation function. 
		ArrayList<GroupLocResult> localisation=localiseMin(groupInfo, minFunctuion, locAlgorithm);
		
		if (localisation==null) return null; 
		if (localisation.size()==0) return null; //make life simple
	
		//clear all localisation results. 
		GroupLocalisation groupLoc = getGroupLocalisation(pamDataUnit);
//		if (addLoc) groupLoc=pamDataUnit.getGroupDetectionLocalisation();
//		else groupLoc=new GroupLocalisation(pamDataUnit, null); 
//		groupLoc.clearLocResults(); 
		
		
		for (int i=0; i<localisation.size() ;i++){
			
//			System.out.println("DetectionGroupLocaliser2: Localiser Result: " + localisation.get(i).getLatLong()  
//			+ " range: "+localisation.get(i).getPerpendicularDistance()+ " depth: "+localisation.get(i).getLatLong().getHeight() + " no. units: " +pamDataUnit.getSubDetectionsCount());
			Double perpDist = localisation.get(i).getPerpendicularDistance();
			if (perpDist == null) {
				continue;
			}
			if (perpDist > Math.PI*2*PamConstants.EARTH_RADIUS_METERS ){
//				System.err.println("DetectionGroupLocalisert2: The perpindicular distance is greater than the earth's radius. Runaway localisation. Return null");
				//probabaly a runaway localisation. 
				continue;
			}
			
			groupLoc.addGroupLocaResult(localisation.get(i));
			
			//now add loc contents
			groupLoc.addLocContents(LocContents.HAS_BEARING);
			groupLoc.addLocContents(LocContents.HAS_LATLONG);
			groupLoc.addLocContents(LocContents.HAS_PERPENDICULARERRORS);
			groupLoc.addLocContents(LocContents.HAS_RANGE);
			groupLoc.addLocContents(LocContents.HAS_RANGEERROR);
			
			if (localisation.get(i).getLatLong().getHeight()!=0 && localisation.get(i).getLatLong().getHeight()!=Double.NaN){
				groupLoc.addLocContents(LocContents.HAS_DEPTH);
				groupLoc.addLocContents(LocContents.HAS_DEPTHERROR);
			}
			
			//Print some stuff.
		
//			System.out.println("DetectionGroupLocaliser2: error direction: " +
//					"err: "+localisation.get(i).getLocError());
//			
//			System.out.println("DetectionGroupLocaliser2: aix chi2: " +
//					"err: "+localisation.get(i).getAic()+" "+localisation.get(i).getChi2());
			
//			System.out.println("DetectionGroupLocaliser2: error direction: " + Math.toDegrees(localisation.get(i).getErrorDirection())+
//					" perp err: "+localisation.get(i).getPerpendicularDistanceError()+ " parallel err: "+localisation.get(i).getParallelError());
		
		}
		

		return groupLoc;
	}
	
	/**
	 * Get a group localisation from a data unit if it exists, otherwise create one. 
	 * @param pamDataUnit
	 * @return old or freshly created grouploc.
	 */
	private GroupLocalisation getGroupLocalisation(PamDataUnit pamDataUnit) {
		AbstractLocalisation loc = pamDataUnit.getLocalisation();
		if (loc == null || !GroupLocalisation.class.isAssignableFrom(loc.getClass())) {
			return new GroupLocalisation(pamDataUnit, null);
		}
		else {
			GroupLocalisation groupLoc = (GroupLocalisation) loc;
			groupLoc.clearLocResults();
			return groupLoc;
		}
	}
 

	/**
	 * Use an algorithm to solve the minimisation function
	 * @param minFunctuion - the minimisation functions to solve for that particular localisation. 
	 * @return 
	 */
	public ArrayList<GroupLocResult> localiseMin(GroupLocInfo groupInfo, MinimisationFunction[] minFunctuion, MinimisationAlgorithm locAlgorithm){

		try{ //TEMP
		//don;t how many result the algorithm might return- depends on whether there are ambiguities or not. 
		ArrayList<GroupLocResult> groupResult=new ArrayList<GroupLocResult>(); 
		
		int n=0; //ambiguity count
		//iterate through ambiguities and localise. 
		for (int i=0; i<minFunctuion.length; i++){

			//2D Simplex localiser. 
			locAlgorithm.setMinimisationFunction(minFunctuion[i]);
			boolean success = locAlgorithm.runAlgorithm();
			if (success == false) {
				continue;
			}
			
			double[][] resultLoc=locAlgorithm.getResult();
			double chiAgain = minFunctuion[i].value(resultLoc[0]);
			LocaliserError[] resultLocError=locAlgorithm.getErrors();
			double[] chiSquared=locAlgorithm.getChi2();
			
			//System.out.println(" Errors " + resultLocError[0][0]);

			//iterate through the ambiguities
			if (resultLoc==null) continue;
			
			for (int j=0; j<resultLoc.length; j++){
				//create group result 
				LatLong latLong=groupInfo.metresToLatLong(new PamVector(resultLoc[j][0], resultLoc[j][1], 0));
				if (minFunctuion[i].getDim() == 3) latLong.setHeight(resultLoc[j][2]); //might have depth data too. 
				
				//System.out.println("DetectionGroupLoclaiser: "+simplex.getResult()[0]+" "+simplex.getResult()[1] + " Lat long: " + latLong.toString())
				groupResult.add(new GroupLocResult(this, latLong , n, locAlgorithm.getChi2()[j])); 
				groupResult.get(n).setDim(minFunctuion[i].getDim());
												
				//beam time. this might be redundant but used in target motion loclalisation 
				groupResult.get(n).setBeamLatLong(groupInfo.getBeamLatLong(groupResult.get(n).getLatLong()));
				groupResult.get(n).setBeamTime(groupInfo.getBeamTime(groupResult.get(n).getLatLong()));
				
				//calculate perpindicular errors. 
//				double perpAngle=groupResult.get(n).getErrorDirection(); 
//				double errPerp=Math.abs(groupResult.get(n).getYError()*Math.cos(perpAngle));
//				double errParallel=Math.abs(groupResult.get(n).getXError()*Math.cos(perpAngle)); 
				LatLong beamLatlong = groupResult.get(n).getBeamLatLong();
				LatLong resultLatLong = groupResult.get(n).getLatLong();
				if (beamLatlong != null && resultLatLong != null) {
					groupResult.get(n).setPerpendicularDistance(beamLatlong.distanceToMetres(resultLatLong));
				}
//				groupResult.get(n).setPerpendicularDistanceError(errPerp);
//				groupResult.get(n).setParallelError(errParallel); 
				
//				http://stats.stackexchange.com/questions/37678/relation-between-reduced-chi-square-and-akaike-criterion
				// chiSquared[j] is the raw chi2. 
				int nData = groupInfo.getDetectionCount();
				int nDims = minFunctuion[i].getDim();
				double reducedChi2 = chiSquared[j];
				if (nData > nDim) {
					reducedChi2 /= (nData - nDim);
				}
				groupResult.get(n).setChi2(reducedChi2);
				groupResult.get(n).setAic(chiSquared[j]+2*nDims);
				
				//Error
				groupResult.get(n).setError(resultLocError[j]);
				

				if (beamLatlong != null && resultLatLong != null) {
					groupResult.get(n).setPerpErrorVector(PamVector.fromHeadAndSlant(beamLatlong.bearingTo(resultLatLong),0));//TODO. //errors are georeferenced so vector is just north. 
				}
				
				//need to add in perpindicular error term here. 
				//if (resultLocError[j] instanceof SimpleError) ((SimpleError) resultLocError[j]).setPerpVector(groupResult.get(n).getErrorVector()); 
				
				//				System.out.println("DtectionGroupLoclaiser2: errorVector: "+groupResult.get(n).getPerpendicularDistanceError()); 


				//FIXME- need a better approach here. 
				PamVector[] worldVecs = groupInfo.getParentDetection().getSubDetection(0).getLocalisation().getWorldVectors();
				int jj = Math.min(worldVecs.length-1, i);
				groupResult.get(n).setFirstBearing(worldVecs[jj]);
				
				n++; 

			}
			
		}
		
		return groupResult; 

		}
		catch (Exception e){
			e.printStackTrace();
			return null; 
		}

	}
	
	
	
	/**
	 * Create a minimisation function. Sets up the problem. 
	 * @param groupInfo - the GroupLocInfo class which organises localisation information for group localisations. 
	 * @param locType - integer flag for the type of localisation information to use/ 
	 * @return an array of problems to solve. Will contain multiple minimisation functions if potential ambiguities exist. 
	 */
	public MinimisationFunction[] getMinimsationFunc(GroupLocInfo groupInfo, int locType){
		
		//set up the the function for forward problem. 
		MinimisationFunction[] minFunctuions=null;   
		switch (locType){
		case BEARINGS_GROUP:
			minFunctuions=new MinimisationFunction[groupInfo.getAmbiguityCount(this.getLocDim())];
			//now we might have a 3D localiser attempting to solve a 2D problem. In this case there may be two minFunctions for 2D data but only one for 
			//3D solution...
			int nMinFunc=minFunctuions.length; 
//			if (this.nDim==3){
//				//TODO - there maybe situation were this is untrue for more complex problems- at the moment however, a targer motion loclaisation loclaised for 3D
//				//will only have one solution....
//				nMinFunc=1; 
//			}
			for (int i=0; i<nMinFunc; i++){
				PamVector[] angleErrors = groupInfo.getWorldVectorErrors(i);
				minFunctuions[i]=new Chi2Bearings(groupInfo.getWorldVectors(i), angleErrors, groupInfo.getOrigins(), groupInfo.getRotationVectors(), nDim); 
			}
			break;
		case TIMEDELAY_GROUP:
			//time delay ambiguities are determined by localisation algorithms as it is essentially a more 'raw' form of localisation data. 
			minFunctuions=new MinimisationFunction[1];
			minFunctuions[0]=new Chi2TimeDelays(groupInfo.getTimeDelays(), groupInfo.getTimeDelays(), groupInfo.getHydrophonePos());
			break; 
		case AUTOMATIC:
			minFunctuions=getMinimsationFunc( groupInfo, BEARINGS_GROUP);
			break; 
		}
		
		return minFunctuions; 
	}
	
	/**
	 * Get the locType. This is the type of information which is used in the loclaisation e.g. bearings, time delays. 
	 * @return an integer flag of the locType
	 */
	public int getLocType() {
		return locType;
	}

	/**
	 * Set the locType. This is the type of information which is used in the localisation e.g. bearings, time delays. 
	 * @param an integer flag of the locType e.g. BEARINGS_GROUP, TIMEDELAY_GROUP; 
	 */
	public void setLocType(int locType) {
		this.locType = locType;
	}
	
	/*
	 * Set the number of dimensions to solve for. Usually 2 or 3. (2 for x and y and 3 for x, y and depth.)
	 */
	public void setLocDim(int nDim){
		this.nDim=nDim; 
	}
	
	/*
	 * Get the number of dimensions to solve for. Usually 2 or 3. (2 for x and y and 3 for x, y and depth.);
	 * @return the number of dimensions to solve for. 
	 */
	public int getLocDim(){
		return nDim; 
	}
	
	
	/**
	 * Get the group detection info for a PamDataUnit. This is used to 
	 * calculate information from a group of detections 
	 * @param detectionGroupOptions 
	 * @return the groupDetectionIndo 
	 */
	public GroupLocInfo getGroupLocInfo(T PamDetection, DetectionGroupOptions detectionGroupOptions){
		groupLocInfo=new TMGroupLocInfo(PamDetection, detectionGroupOptions); 
		return groupLocInfo;
	}


	@Override
	public void notifyModelProgress(double progress) {
		
	}

	@Override
	public boolean hasParams() {
		return locAlgorithm.hasParams();
	}
	
	/**
	 * Set the algorithm used to solve the loclaisation problem
	 * @param minAlgorithm the loclisation algorithm. 
	 */
	public void setLocalisationAlgorithm(MinimisationAlgorithm minAlgorithm){
		this.locAlgorithm=minAlgorithm; 
	}

}
